// libarchive-harness-win.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <windows.h>

// Declare function pointers for the exported functions
typedef void* (*ArchiveReadNew)();
typedef int (*ArchiveReadSupportFormatAll)(void*);
typedef int (*ArchiveReadOpenFilename)(void*, const char*);
typedef int (*ArchiveReadNextHeader)(void*, void**);
typedef int (*ArchiveReadData)(void*, const void**, size_t*, int64_t*);
typedef int (*ArchiveReadClose)(void*);
typedef void (*ArchiveReadFree)(void*);

#define	ARCHIVE_OK	  0	/* Operation was successful. */

int main() {
    // Load the DLL
    HMODULE archiveDll = LoadLibrary(L"archiveint.dll");
    if (!archiveDll) {
        std::cerr << "Error loading archiveint.dll" << std::endl;
        return 1;
    }

    // Get function addresses
    ArchiveReadNew archive_read_new = reinterpret_cast<ArchiveReadNew>(GetProcAddress(archiveDll, "archive_read_new"));
    ArchiveReadSupportFormatAll archive_read_support_format_all = reinterpret_cast<ArchiveReadSupportFormatAll>(GetProcAddress(archiveDll, "archive_read_support_format_all"));
    ArchiveReadOpenFilename archive_read_open_filename = reinterpret_cast<ArchiveReadOpenFilename>(GetProcAddress(archiveDll, "archive_read_open_filename"));
    ArchiveReadNextHeader archive_read_next_header = reinterpret_cast<ArchiveReadNextHeader>(GetProcAddress(archiveDll, "archive_read_next_header"));
    ArchiveReadData archive_read_data = reinterpret_cast<ArchiveReadData>(GetProcAddress(archiveDll, "archive_read_data"));
    ArchiveReadClose archive_read_close = reinterpret_cast<ArchiveReadClose>(GetProcAddress(archiveDll, "archive_read_close"));
    ArchiveReadFree archive_read_free = reinterpret_cast<ArchiveReadFree>(GetProcAddress(archiveDll, "archive_read_free"));

    if (!archive_read_new || !archive_read_support_format_all || !archive_read_open_filename ||
        !archive_read_next_header || !archive_read_data || !archive_read_close || !archive_read_free) {
        std::cerr << "Error getting function addresses" << std::endl;
        FreeLibrary(archiveDll);
        return 1;
    }

    // Example usage: Open an archive file
    void* archive = archive_read_new();
    if (!archive) {
        std::cerr << "Error creating archive object" << std::endl;
        FreeLibrary(archiveDll);
        return 1;
    }

    archive_read_support_format_all(archive);
    if (archive_read_open_filename(archive, "path/to/your/archive.tar") != ARCHIVE_OK) {
        std::cerr << "Error opening archive file" << std::endl;
        archive_read_free(archive);
        FreeLibrary(archiveDll);
        return 1;
    }

    // Process headers and data (add your logic here)

    // Clean up
    archive_read_close(archive);
    archive_read_free(archive);
    FreeLibrary(archiveDll);

    return 0;
}


// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file




// https://github.com/libarchive/libarchive/blob/master/libarchive/test/test_read_format_rar_invalid1.c
//#include "test.h"
//
//DEFINE_TEST(test_read_format_rar_invalid1)
//{
//	const char* refname = "test_read_format_rar_invalid1.rar";
//	struct archive* a;
//	struct archive_entry* ae;
//	char* buff[100];
//
//	extract_reference_file(refname);
//	assert((a = archive_read_new()) != NULL);
//	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));
//	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_all(a));
//	assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 10240));
//	assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));
//	assertEqualIntA(a, ARCHIVE_FATAL, archive_read_data(a, buff, 99));
//	assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));
//	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
//}

//Barchive_read_new, archive_read_support_format_all, archive_read_open_filename, archive_read_next_header, archive_read_data, archive_read_close, archive_read_free